require 'optparse'
require 'timeout'

module ExploitLoop
  VERSION = '11.1.3'
  
  class Run
    
    class << self
      def default_options
        {
          :minimum => 60,
          :exploit_dir => File.dirname(__FILE__) + "/../exploits",
          :flag_dir => File.dirname(__FILE__) + "/../flags",
          :timeout => 3,
          :target_network => "10.0.x.y",
          :target_host => 3,
          :target_range => 0..10,
          :without => "10.0.5.3",
        }
      end
      
      def parse_options
        options = default_options
        
        executable_name = File.basename(__FILE__).sub(/\.rb$/,'')
        
        OptionParser.new do |opts|
          opts.banner  = "% #{executable_name} [options]"
          opts.version = ::ExploitLoop::VERSION
          opts.separator ""
          opts.separator "Specific options:"
          opts.separator ""
          
          opts.on('-h', '--help', 'Display this help.') do
            abort "#{opts}"
          end
          opts.on('-V', '--version', 'Print version.') do |s|
            abort("#{executable_name} #{::ExploitLoop::VERSION}")
          end
          
          opts.on('--minimum <i>', 'Minimum iteration time in seconds.') do |s|
            options[:minimum] = s.to_i
          end
          opts.on('--exploit_dir <dir>', 'Directory that contains exploits.') do |s|
            options[:exploit_dir] = s
          end
          opts.on('--flag_dir <dir>', 'Directory in which flags are written to.') do |s|
            options[:flag_dir] = s
          end
          opts.on('--timeout <sec>', 'Timeout in seconds for blocking calls.') do |s|
            i = s.to_i
            options[:timeout] = i if i > 0
          end
          opts.on('--without <host>', 'Without this host') do |s|
            options[:without] = s
          end
          opts.on('--target_network <network>', 'network like 10.0.x.y , where "x" will be changed according to --target_range and "y" will be changed according to --target_host.') do |s|
            options[:target_network] = s
          end
          opts.on('--target_host <y>', 'Host address, the "y" within --target_network.') do |s|
            i = s.to_i
            if i > 0 and i < 255
              options[:target_host] = i 
            else
              abort "--target_host <#{s}> is not a correct parameter."
            end
          end
          opts.on('--target_range <x>', 'Network range, the "x" within --target_network. Example: 5,23 will be a Range 5..23') do |s|
            a,b = s.strip.split(",").map {|w| w.to_i}
            if a >= 0 and a <= 255 and b >= 0 and b <= 255
              a,b = b,a if a > b
              options[:target_range] = a..b
            else
              abort "--target_range <#{s}> is not a correct parameter."
            end
          end
          
          begin
            opts.parse!
          rescue => e
            abort "#{e}\n\n#{opts}"
          end
        end
        options
      end
      
      def main(options)
        el_runner = ExploitLoop::Run.new(options)
        el_runner.main_loop
        
        return 0
      end
    end # class methods end
    
    def initialize(options)
      @min_iteration_time = options[:minimum]
      @exploit_dir = File.expand_path(options[:exploit_dir])
      @flag_dir = File.expand_path(options[:flag_dir])
      @timeout = options[:timeout]
      options[:target_network].sub!("y", options[:target_host].to_s)
      @targets = options[:target_range].map {|i| options[:target_network].sub("x",i.to_s)}.
                                        select {|w| w != options[:without]}
      log "targets: #{@targets.join(' ')}"
    end
    
    def main_loop
      trap("INT") {log("CTRL-C caught, exit now!"); exit!(0)}
      loop do
        time_before = Time.now
        @targets.each do |target|
          Dir["#{@exploit_dir}/**/*"].select {|w| File.extname(w) != ".off"}.
                                      each do |exploit|
            if FileTest.executable?(exploit)
              run_safe(exploit,target)
            end
          end
        end
        wait_time = (@min_iteration_time - (Time.now - time_before).to_i)
        log "wait_time:#{wait_time}"
        if wait_time > 0
          sleep wait_time
        end
      end
    end
    
    private
    
    def run_safe(exploit,target)
      exploit_name = File.basename(exploit)
      begin
        timeoutx @timeout do
          system("#{exploit} --target #{target} >> #{@flag_dir}/#{Time.now.to_i}_#{exploit_name}")
        end
      rescue Exception => e
        log e
      ensure
        log "exploit:#{exploit_name}"
      end
    end
    
    # ara t.howard - gist
    def timeoutx(seconds, &block)
      r, w = IO.pipe
      cid = fork
      parent = cid

      if parent
        w.close
        pipe = r
        Timeout.timeout(seconds) do
          result = Marshal.load(pipe.read) rescue nil
        end
      else
        r.close
        pipe = w
        result = block.call()
        pipe.write(Marshal.dump(result)) rescue nil
        exit!
      end
    end
    
    def log(msg)
      STDERR.puts "log: #{msg}"
    end
  end
end

